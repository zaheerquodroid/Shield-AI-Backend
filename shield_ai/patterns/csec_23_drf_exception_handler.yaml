pattern_id: csec_23_drf_exception_handler
name: "Missing DRF Custom Exception Handler"
category: error_handling
severity: high
description: |
  Detects Django REST Framework projects without a custom exception handler.
  Without a custom handler, unhandled exceptions may expose sensitive information:
  - Stack traces with code snippets
  - Internal file paths
  - Database schema details
  - Environment configuration

  A custom exception handler should:
  - Sanitize all unhandled exceptions
  - Log errors server-side for debugging
  - Return generic error messages to clients
  - Provide detailed errors only in DEBUG mode

jira_reference:
  ticket: CSEC-23
  epic: CSEC-2
  project: "Coco TestAI Security Remediation"

detection:
  # Python patterns for missing DRF exception handler
  python:
    - pattern: 'REST_FRAMEWORK\s*=\s*\{'
      description: "REST_FRAMEWORK configuration found"
      requires_absence: "'EXCEPTION_HANDLER'"
      example: |
        REST_FRAMEWORK = {
            'DEFAULT_AUTHENTICATION_CLASSES': [...],
            # Missing EXCEPTION_HANDLER
        }

    - pattern: 'from\s+rest_framework'
      description: "DRF import detected in settings"
      requires_absence: "EXCEPTION_HANDLER"
      check_file: true

file_patterns:
  - "**/*settings*.py"
  - "**/settings/*.py"
  - "**/config/*.py"

risk_assessment:
  impact: high
  exploitability: medium
  affected_scope: api_security
  labels:
    - P0-Critical
    - security
    - backend
    - extension-launch
    - api

  risks:
    - "Unhandled exceptions expose stack traces to API clients"
    - "Internal file paths and code snippets leaked"
    - "Database connection errors reveal schema information"
    - "Third-party library errors expose dependencies"
    - "Makes it easier for attackers to find vulnerabilities"

fix_strategy:
  approach: create_handler_and_configure
  breaking_change: false
  description: |
    Create a custom exception handler that sanitizes all unhandled exceptions
    while maintaining compatibility with existing DRF error handling.

  phases:
    - name: detection
      duration_days: 0
      description: "Scan for DRF projects without custom exception handler"

    - name: handler_creation
      duration_days: 0
      description: "Create custom exception handler file"

    - name: configuration
      duration_days: 0
      description: "Update settings to use custom handler"

    - name: testing
      duration_days: 1
      description: "Test with various exception types"

handler_template:
  file_path: "interpreter/utils/exception_handler.py"
  description: "Custom DRF exception handler with sanitization"
  features:
    - "Handles all DRF exceptions normally"
    - "Sanitizes unhandled exceptions"
    - "Logs full details server-side"
    - "DEBUG-aware error responses"
    - "Configurable error messages"

settings_update:
  key: "REST_FRAMEWORK['EXCEPTION_HANDLER']"
  value: "interpreter.utils.exception_handler.custom_exception_handler"
  description: "Configure DRF to use custom exception handler"

acceptance_criteria:
  - "Custom exception handler file created at interpreter/utils/exception_handler.py"
  - "Settings updated with EXCEPTION_HANDLER configuration"
  - "DRF exceptions handled normally (validation errors, etc.)"
  - "Unhandled exceptions return generic error messages"
  - "Full exception details logged server-side"
  - "DEBUG mode shows detailed errors for development"
  - "Production mode sanitizes all error details"
  - "Tests verify all exception types handled correctly"

estimated_effort:
  detection: "5 minutes"
  handler_creation: "2 hours"
  settings_update: "10 minutes"
  testing: "1 hour"
  total: "3.5 hours"

debug_mode_behavior:
  when_debug_true:
    response:
      error: "Exception class name"
      detail: "Full exception message"
      traceback: "Full Python traceback"
    purpose: "Help developers debug issues locally"

  when_debug_false:
    response:
      error: "Internal server error"
      detail: "Generic message, no technical details"
    purpose: "Prevent information disclosure in production"

logging_strategy:
  level: "ERROR"
  includes:
    - "Exception class name and message"
    - "Full traceback"
    - "Request context (view, method, path)"
    - "User information (if authenticated)"
  excludes:
    - "Passwords and secrets"
    - "Session tokens"
    - "API keys"
  sanitization: "Apply regex patterns to remove sensitive data"

notes: |
  This is a complementary fix to bare except handling (CSEC-23 Task 2.3.1).
  Together they provide defense-in-depth:

  1. Bare except fixes → Catch specific exceptions where possible
  2. Global handler → Sanitize anything that wasn't caught

  The global handler is the last line of defense for information disclosure,
  ensuring that even if specific exception handling is missed, sensitive
  information is not leaked to API clients.

  Integration points:
  - Works with existing DRF exception handling
  - Compatible with third-party DRF packages
  - Can be extended with custom error formats
  - Supports error tracking services (Sentry, etc.)
