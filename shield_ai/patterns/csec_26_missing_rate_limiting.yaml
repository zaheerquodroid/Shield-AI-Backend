pattern_id: csec_26_missing_rate_limiting
name: "Missing DRF Rate Limiting Configuration"
category: rate_limiting
severity: high
description: |
  Detects Django REST Framework projects without proper rate limiting configuration.
  Missing rate limiting allows brute force attacks on authentication endpoints:
  - Login endpoints vulnerable to credential stuffing
  - Signup endpoints vulnerable to spam/abuse
  - Password reset vulnerable to enumeration
  - MFA endpoints vulnerable to bypass attempts
  - General API vulnerable to DoS attacks

  Rate limiting should be configured for:
  - Authentication endpoints (login, signup, password reset, MFA)
  - General API endpoints (different rates for authenticated vs anonymous)

jira_reference:
  ticket: CSEC-26
  epic: CSEC-4
  project: "Coco TestAI Security Remediation"

detection:
  # Python patterns for missing rate limiting
  python:
    # Check 1: Missing DEFAULT_THROTTLE_CLASSES in REST_FRAMEWORK
    - pattern: 'REST_FRAMEWORK\s*=\s*\{[^}]*\}'
      description: "REST_FRAMEWORK configuration without throttling"
      example: |
        REST_FRAMEWORK = {
            'DEFAULT_AUTHENTICATION_CLASSES': [...],
            # Missing DEFAULT_THROTTLE_CLASSES
        }

    # Check 2: Login views without throttle_classes
    - pattern: 'class\s+\w*Login\w*\(.*APIView'
      description: "Login view potentially missing rate limiting"
      example: |
        class LoginView(APIView):
            # Missing throttle_classes attribute

    # Check 3: Signup/Register views without throttling
    - pattern: 'class\s+\w*(?:Signup|Register)\w*\(.*APIView'
      description: "Signup view potentially missing rate limiting"
      example: |
        class SignupView(APIView):
            # Missing throttle_classes attribute

    # Check 4: Password reset views without throttling
    - pattern: 'class\s+\w*PasswordReset\w*\(.*APIView'
      description: "Password reset view potentially missing rate limiting"
      example: |
        class PasswordResetView(APIView):
            # Missing throttle_classes attribute

    # Check 5: MFA/OTP verification views without throttling
    - pattern: 'class\s+\w*(?:MFA|OTP|TwoFactor)\w*(?:Verify|)\w*\(.*APIView'
      description: "MFA verification view potentially missing rate limiting"
      example: |
        class MFAVerifyView(APIView):
            # Missing throttle_classes attribute

file_patterns:
  - "**/*settings*.py"
  - "**/settings/*.py"
  - "**/views.py"
  - "**/*views*.py"
  - "**/views/*.py"
  - "**/auth/*.py"
  - "**/authentication/*.py"
  - "**/api/*.py"

risk_assessment:
  impact: high
  exploitability: high
  affected_scope: authentication_security
  labels:
    - P0-Critical
    - security
    - backend
    - extension-launch
    - authentication
    - wrapper

  risks:
    - "Brute force attacks on login endpoints"
    - "Credential stuffing attacks (automated login attempts)"
    - "Account enumeration via timing attacks"
    - "Denial of service via API flooding"
    - "Signup spam and fake account creation"
    - "Password reset enumeration"
    - "MFA bypass via brute force"

fix_strategy:
  approach: three_phase_rollout
  breaking_change: false
  description: |
    Implement rate limiting with a phased approach to avoid blocking legitimate users.
    Start with permissive limits, monitor traffic, then tighten to target rates.

  phases:
    - name: detection
      duration_days: 0
      description: "Scan for missing rate limiting configuration"

    - name: warning
      duration_days: 7
      description: |
        Enable throttling with high limits (10x target)
        Log violations but don't block
        Monitor false positive rate

    - name: soft_enforcement
      duration_days: 7
      description: |
        Reduce limits to 2x target
        Block violations, return 429
        Monitor user complaints

    - name: full_enforcement
      duration_days: ongoing
      description: |
        Set final target limits
        Enable login lockout
        Continuous monitoring

rate_limits:
  target:
    login: "5/min per IP"
    signup: "3/min per IP"
    password_reset: "3/min per IP"
    mfa_verify: "5/min per IP"
    authenticated_api: "100/min per user"
    anonymous_api: "20/min per IP"

  warning_phase:
    login: "50/min"
    signup: "30/min"
    password_reset: "30/min"
    mfa_verify: "50/min"
    authenticated_api: "1000/min"
    anonymous_api: "200/min"

  soft_enforcement:
    login: "10/min"
    signup: "6/min"
    password_reset: "6/min"
    mfa_verify: "10/min"
    authenticated_api: "200/min"
    anonymous_api: "40/min"

throttle_configuration:
  cache_backend: "django.core.cache.backends.redis.RedisCache"
  cache_location: "redis://127.0.0.1:6379/1"
  headers:
    - "X-RateLimit-Limit"
    - "X-RateLimit-Remaining"
    - "X-RateLimit-Reset"
    - "Retry-After"
  response_code: 429
  response_message: "Too many requests. Please try again later."

login_lockout:
  enabled: true
  max_attempts: 10
  lockout_duration: 3600  # 1 hour in seconds
  lockout_message: "Account locked due to multiple failed login attempts"
  unlock_methods:
    - "automatic_after_timeout"
    - "email_verification"
    - "admin_unlock"

acceptance_criteria:
  - "Login endpoint limited to 5 attempts/minute per IP"
  - "Signup endpoint limited to 3 attempts/minute per IP"
  - "Password reset limited to 3 attempts/minute per IP"
  - "MFA verify limited to 5 attempts/minute per IP"
  - "Authenticated API limited to 100 req/min per user"
  - "Anonymous API limited to 20 req/min per IP"
  - "Rate limit headers included in responses"
  - "429 status code returned when limit exceeded"
  - "Account locked after 10 failed login attempts"
  - "Locked accounts unlock after 1 hour timeout"

estimated_effort:
  detection: "30 minutes"
  throttle_classes: "2 hours"
  settings_config: "30 minutes"
  view_decorators: "1.5 hours"
  login_lockout: "5 hours"
  testing: "4 hours"
  documentation: "1 hour"
  total: "14.5 hours"

dependencies:
  required:
    - "djangorestframework>=3.12.0"
    - "django>=3.2.0"
  recommended:
    - "redis>=4.0.0"
    - "django-redis>=5.0.0"
  optional:
    - "django-ratelimit>=3.0.0"
    - "django-axes>=5.0.0"  # Alternative lockout implementation

notes: |
  Rate limiting is critical for authentication security but must be implemented
  carefully to avoid blocking legitimate users:

  1. Use Redis cache backend (not database) for performance
  2. Monitor false positive rates during rollout
  3. Implement unlock mechanisms (email, admin)
  4. Consider geographic rate limits for high-risk regions
  5. Add CAPTCHA after multiple failed attempts
  6. Log all throttling events for security monitoring
  7. Test with production traffic patterns before full rollout
  8. Provide clear error messages with retry-after headers

  Integration with existing patterns:
  - Works with CSEC-23 DRF exception handler for error responses
  - Complements CSEC-20 ALLOWED_HOSTS for request validation
  - Can integrate with monitoring/alerting systems
