"""
Shield AI - CSEC-33 Fix Template
PostgreSQL Row-Level Security (RLS) for Tenant Isolation

This template provides comprehensive RLS implementation for Django multi-tenant applications.

Components:
1. Django migration template for enabling RLS
2. Middleware for setting tenant context
3. Database user configuration
4. Integration test templates
5. WebSocket consumer integration
6. Documentation

Usage:
    1. Identify models with tenant_id/tenant FK
    2. Create migration using MIGRATION_TEMPLATE
    3. Add TenantRLSMiddleware to settings
    4. Configure database users with proper privileges
    5. Run integration tests
    6. Deploy with phased rollout

CRITICAL: PostgreSQL 9.5+ required for RLS support
"""

# ============================================================================
# 1. DJANGO MIGRATION TEMPLATE
# ============================================================================

MIGRATION_TEMPLATE = '''"""
Enable Row-Level Security (RLS) for tenant isolation

Generated by Shield AI - CSEC-33
Database: PostgreSQL 9.5+
"""

from django.db import migrations


class Migration(migrations.Migration):
    """
    Enable PostgreSQL Row-Level Security on tenant-scoped tables.

    IMPORTANT: This migration must run with a database user that has
    BYPASSRLS privilege (typically the migration/superuser).

    Tables affected: {table_list}
    """

    dependencies = [
        # Add your app dependencies here
        ('your_app', 'previous_migration'),
    ]

    operations = [
        # Enable RLS on each tenant-scoped table
        migrations.RunSQL(
            sql="""
            -- ============================================================
            -- ENABLE ROW-LEVEL SECURITY
            -- ============================================================

            {enable_rls_sql}

            -- ============================================================
            -- CREATE RLS POLICIES
            -- ============================================================

            {create_policies_sql}

            -- ============================================================
            -- GRANT PERMISSIONS
            -- ============================================================

            -- Application user can use the table but RLS is enforced
            GRANT SELECT, INSERT, UPDATE, DELETE ON {table_list_comma} TO app_user;

            -- Migration user bypasses RLS for migrations
            ALTER USER migration_user WITH BYPASSRLS;

            """,
            reverse_sql="""
            -- Drop all RLS policies
            {drop_policies_sql}

            -- Disable RLS on all tables
            {disable_rls_sql}
            """,
        ),
    ]
'''

# SQL template for enabling RLS on a single table
ENABLE_RLS_SQL_TEMPLATE = """
-- Enable RLS on {table_name}
ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY;
ALTER TABLE {table_name} FORCE ROW LEVEL SECURITY;  -- Applies to table owner too
"""

# SQL template for creating RLS policy
CREATE_POLICY_SQL_TEMPLATE = """
-- Policy for {table_name}: tenant isolation
CREATE POLICY tenant_isolation_policy_{table_name_clean}
ON {table_name}
USING ({tenant_column} = current_setting('app.current_tenant_id')::int);

-- Policy for INSERT: automatically set tenant_id
CREATE POLICY tenant_isolation_insert_{table_name_clean}
ON {table_name}
FOR INSERT
WITH CHECK ({tenant_column} = current_setting('app.current_tenant_id')::int);

-- Policy for UPDATE: prevent changing tenant_id
CREATE POLICY tenant_isolation_update_{table_name_clean}
ON {table_name}
FOR UPDATE
USING ({tenant_column} = current_setting('app.current_tenant_id')::int)
WITH CHECK ({tenant_column} = current_setting('app.current_tenant_id')::int);

-- Policy for DELETE: only delete own tenant's rows
CREATE POLICY tenant_isolation_delete_{table_name_clean}
ON {table_name}
FOR DELETE
USING ({tenant_column} = current_setting('app.current_tenant_id')::int);
"""

# SQL template for dropping RLS policy
DROP_POLICY_SQL_TEMPLATE = """
DROP POLICY IF EXISTS tenant_isolation_policy_{table_name_clean} ON {table_name};
DROP POLICY IF EXISTS tenant_isolation_insert_{table_name_clean} ON {table_name};
DROP POLICY IF EXISTS tenant_isolation_update_{table_name_clean} ON {table_name};
DROP POLICY IF EXISTS tenant_isolation_delete_{table_name_clean} ON {table_name};
"""

# SQL template for disabling RLS
DISABLE_RLS_SQL_TEMPLATE = """
ALTER TABLE {table_name} DISABLE ROW LEVEL SECURITY;
"""


# ============================================================================
# 2. TENANT RLS MIDDLEWARE
# ============================================================================

MIDDLEWARE_TEMPLATE = '''"""
Middleware to set PostgreSQL tenant context for Row-Level Security (RLS)

This middleware sets the app.current_tenant_id PostgreSQL configuration
parameter on each request, which is used by RLS policies to filter data.

Add to settings.py MIDDLEWARE (early in the list, after authentication):
    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'middleware.tenant_rls.TenantRLSMiddleware',  # Add this
        # ... rest of middleware
    ]
"""

from django.db import connection
from django.utils.deprecation import MiddlewareMixin
import logging

logger = logging.getLogger(__name__)


class TenantRLSMiddleware(MiddlewareMixin):
    """
    Set PostgreSQL app.current_tenant_id for Row-Level Security.

    This middleware extracts the tenant_id from the authenticated user
    and sets it as a PostgreSQL session variable. RLS policies use this
    variable to filter queries automatically.

    CRITICAL: This middleware must run AFTER AuthenticationMiddleware
    so that request.user is populated.
    """

    def process_request(self, request):
        """Set tenant context before processing request"""

        # Skip for unauthenticated requests
        if not hasattr(request, 'user') or not request.user.is_authenticated:
            logger.debug("Skipping RLS for unauthenticated request")
            return None

        # Skip for superusers (they should see all data)
        if request.user.is_superuser:
            logger.debug(f"Skipping RLS for superuser: {request.user.username}")
            return None

        # Get tenant_id from user
        tenant_id = getattr(request.user, 'tenant_id', None)

        if tenant_id is None:
            # Check if user has tenant FK
            if hasattr(request.user, 'tenant'):
                tenant_id = request.user.tenant.id if request.user.tenant else None

        if tenant_id is None:
            logger.warning(
                f"User {request.user.username} has no tenant_id. "
                f"RLS will block all queries!"
            )
            # Set to -1 to ensure RLS blocks everything
            tenant_id = -1

        # Set PostgreSQL session variable
        try:
            with connection.cursor() as cursor:
                cursor.execute(
                    "SET LOCAL app.current_tenant_id = %s",
                    [tenant_id]
                )
            logger.debug(f"Set RLS tenant context: {tenant_id} for user {request.user.username}")
        except Exception as e:
            logger.error(f"Failed to set RLS context: {e}")
            # Re-raise to prevent request from proceeding without RLS
            raise

        return None

    def process_response(self, request, response):
        """Clean up tenant context after request"""
        # PostgreSQL automatically resets SET LOCAL at transaction end,
        # but we can explicitly reset for clarity
        try:
            with connection.cursor() as cursor:
                cursor.execute("RESET app.current_tenant_id")
        except Exception:
            # Ignore errors on cleanup
            pass

        return response


class TenantRLSTestingMiddleware(MiddlewareMixin):
    """
    Testing variant that allows manual tenant_id override via header.

    DO NOT USE IN PRODUCTION! This is only for testing RLS policies.

    Usage in tests:
        response = client.get('/api/data/', HTTP_X_TENANT_ID='123')
    """

    def process_request(self, request):
        # Check for test tenant override
        tenant_id_override = request.META.get('HTTP_X_TENANT_ID')

        if tenant_id_override:
            logger.warning(f"TEST MODE: Overriding tenant_id to {tenant_id_override}")
            tenant_id = int(tenant_id_override)
        elif hasattr(request, 'user') and request.user.is_authenticated:
            tenant_id = getattr(request.user, 'tenant_id', -1)
        else:
            tenant_id = -1

        with connection.cursor() as cursor:
            cursor.execute(
                "SET LOCAL app.current_tenant_id = %s",
                [tenant_id]
            )

        return None
'''


# ============================================================================
# 3. WEBSOCKET CONSUMER INTEGRATION
# ============================================================================

WEBSOCKET_CONSUMER_TEMPLATE = '''"""
WebSocket Consumer with RLS tenant context

WebSocket connections need to set tenant context just like HTTP requests.
"""

from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from django.db import connection
import logging

logger = logging.getLogger(__name__)


class TenantAwareWebSocketConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer that sets RLS tenant context.

    Usage:
        class ChatConsumer(TenantAwareWebSocketConsumer):
            async def receive(self, text_data):
                # RLS automatically filters queries
                messages = await self.get_messages()
    """

    async def connect(self):
        """Set tenant context on WebSocket connection"""
        # Get user from scope (populated by AuthMiddleware)
        user = self.scope.get('user')

        if not user or not user.is_authenticated:
            logger.warning("Rejecting unauthenticated WebSocket connection")
            await self.close()
            return

        # Set tenant context
        tenant_id = getattr(user, 'tenant_id', None)
        if tenant_id is None and hasattr(user, 'tenant'):
            tenant_id = user.tenant.id if user.tenant else None

        if tenant_id is None:
            logger.error(f"User {user.username} has no tenant_id")
            await self.close()
            return

        # Set RLS context in database
        await self.set_rls_context(tenant_id)

        # Store tenant_id for later use
        self.tenant_id = tenant_id

        await self.accept()
        logger.info(f"WebSocket connected for tenant {tenant_id}")

    @database_sync_to_async
    def set_rls_context(self, tenant_id):
        """Set PostgreSQL tenant context"""
        with connection.cursor() as cursor:
            cursor.execute(
                "SET LOCAL app.current_tenant_id = %s",
                [tenant_id]
            )

    async def disconnect(self, close_code):
        """Clean up on disconnect"""
        logger.info(f"WebSocket disconnected for tenant {getattr(self, 'tenant_id', 'unknown')}")
'''


# ============================================================================
# 4. DATABASE USER CONFIGURATION
# ============================================================================

DATABASE_USER_SETUP_SQL = '''
-- ============================================================================
-- PostgreSQL User Configuration for RLS
-- ============================================================================

-- 1. Create application user (RLS enforced)
CREATE USER app_user WITH PASSWORD 'strong_password_here';

-- 2. Create migration user (RLS bypassed)
CREATE USER migration_user WITH PASSWORD 'strong_password_here';
GRANT migration_user TO app_user;  -- Allow migration_user to switch

-- 3. Grant database access
GRANT CONNECT ON DATABASE your_database TO app_user;
GRANT CONNECT ON DATABASE your_database TO migration_user;

-- 4. Grant schema permissions
GRANT USAGE ON SCHEMA public TO app_user;
GRANT USAGE ON SCHEMA public TO migration_user;

-- 5. Grant table permissions
-- (These will be granted by migrations, shown here for reference)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;

-- 6. Grant sequence permissions (for auto-increment IDs)
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO migration_user;

-- 7. Enable BYPASSRLS for migration user
ALTER USER migration_user WITH BYPASSRLS;

-- 8. Ensure app_user does NOT have BYPASSRLS
ALTER USER app_user WITH NOBYPASSRLS;

-- 9. Verify configuration
SELECT rolname, rolsuper, rolbypassrls
FROM pg_roles
WHERE rolname IN ('app_user', 'migration_user');

-- Expected output:
--   rolname        | rolsuper | rolbypassrls
-- -----------------+----------+--------------
--  app_user        | f        | f
--  migration_user  | f        | t
'''


# ============================================================================
# 5. DJANGO SETTINGS CONFIGURATION
# ============================================================================

SETTINGS_TEMPLATE = '''
# ============================================================================
# PostgreSQL RLS Configuration
# ============================================================================

import os

# Database configuration with separate users
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME', 'your_database'),
        'USER': os.environ.get('DB_USER', 'app_user'),  # RLS enforced
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST', 'localhost'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'OPTIONS': {
            # Set default tenant (will be overridden by middleware)
            'options': '-c app.current_tenant_id=-1'
        },
    }
}

# For migrations, use migration_user (BYPASSRLS)
if os.environ.get('DJANGO_MIGRATE') == '1':
    DATABASES['default']['USER'] = 'migration_user'

# Add RLS middleware
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'middleware.tenant_rls.TenantRLSMiddleware',  # Add this after auth
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# Logging configuration for RLS debugging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'middleware.tenant_rls': {
            'handlers': ['console'],
            'level': 'DEBUG' if DEBUG else 'INFO',
        },
    },
}
'''


# ============================================================================
# 6. INTEGRATION TEST TEMPLATE
# ============================================================================

INTEGRATION_TEST_TEMPLATE = '''"""
Integration tests for Row-Level Security (RLS)

These tests verify that:
1. Users can only access data from their own tenant
2. Users cannot access data from other tenants
3. Middleware correctly sets tenant context
4. RLS policies are enforced at database level
"""

from django.test import TestCase, Client
from django.contrib.auth import get_user_model
from your_app.models import Tenant, Document  # Adjust imports

User = get_user_model()


class RLSIntegrationTest(TestCase):
    """Test Row-Level Security tenant isolation"""

    def setUp(self):
        """Create test tenants and users"""
        # Create two tenants
        self.tenant_a = Tenant.objects.create(name="Tenant A")
        self.tenant_b = Tenant.objects.create(name="Tenant B")

        # Create users for each tenant
        self.user_a = User.objects.create_user(
            username='user_a',
            password='password',
            tenant=self.tenant_a
        )
        self.user_b = User.objects.create_user(
            username='user_b',
            password='password',
            tenant=self.tenant_b
        )

        # Create documents for each tenant
        self.doc_a = Document.objects.create(
            tenant=self.tenant_a,
            title="Document A",
            content="Secret A"
        )
        self.doc_b = Document.objects.create(
            tenant=self.tenant_b,
            title="Document B",
            content="Secret B"
        )

    def test_user_can_only_see_own_tenant_data(self):
        """Test that users only see data from their own tenant"""
        # Login as user_a
        client = Client()
        client.login(username='user_a', password='password')

        # Query all documents (RLS should filter automatically)
        from your_app.models import Document
        from django.db import connection

        # Manually set tenant context for this test
        with connection.cursor() as cursor:
            cursor.execute("SET LOCAL app.current_tenant_id = %s", [self.tenant_a.id])

        documents = Document.objects.all()

        # Should only see tenant_a documents
        self.assertEqual(documents.count(), 1)
        self.assertEqual(documents[0].id, self.doc_a.id)
        self.assertIn("Secret A", documents[0].content)

    def test_user_cannot_access_other_tenant_data(self):
        """Test that RLS blocks access to other tenant's data"""
        from your_app.models import Document
        from django.db import connection

        # Set context to tenant_a
        with connection.cursor() as cursor:
            cursor.execute("SET LOCAL app.current_tenant_id = %s", [self.tenant_a.id])

        # Try to access tenant_b's document by ID (should fail)
        try:
            doc = Document.objects.get(id=self.doc_b.id)
            self.fail("RLS should have blocked access to tenant_b's document")
        except Document.DoesNotExist:
            # Expected: RLS filtered out the document
            pass

    def test_cross_tenant_sql_injection_blocked(self):
        """Test that even SQL injection cannot bypass RLS"""
        from your_app.models import Document
        from django.db import connection

        # Set context to tenant_a
        with connection.cursor() as cursor:
            cursor.execute("SET LOCAL app.current_tenant_id = %s", [self.tenant_a.id])

        # Try SQL injection to access tenant_b data
        # Even with raw SQL, RLS should block it
        with connection.cursor() as cursor:
            cursor.execute("SELECT * FROM app_document WHERE id = %s", [self.doc_b.id])
            result = cursor.fetchall()

        # Should be empty due to RLS
        self.assertEqual(len(result), 0)

    def test_middleware_sets_tenant_context(self):
        """Test that middleware correctly sets tenant context"""
        client = Client()
        client.login(username='user_a', password='password')

        # Make request (middleware should set tenant context)
        response = client.get('/api/documents/')  # Adjust URL

        # Should only see tenant_a documents in response
        self.assertEqual(response.status_code, 200)
        # Add assertions based on your API response format

    def test_insert_enforces_tenant_id(self):
        """Test that INSERT policy enforces correct tenant_id"""
        from your_app.models import Document
        from django.db import connection, IntegrityError

        # Set context to tenant_a
        with connection.cursor() as cursor:
            cursor.execute("SET LOCAL app.current_tenant_id = %s", [self.tenant_a.id])

        # Try to insert document for tenant_b (should fail)
        try:
            doc = Document.objects.create(
                tenant=self.tenant_b,  # Wrong tenant!
                title="Malicious Doc",
                content="Trying to bypass RLS"
            )
            self.fail("RLS should have blocked INSERT for wrong tenant")
        except Exception:
            # Expected: RLS policy violation
            pass

    def test_update_cannot_change_tenant_id(self):
        """Test that UPDATE policy prevents changing tenant_id"""
        from your_app.models import Document
        from django.db import connection

        # Set context to tenant_a
        with connection.cursor() as cursor:
            cursor.execute("SET LOCAL app.current_tenant_id = %s", [self.tenant_a.id])

        # Try to change document's tenant (should fail)
        doc = Document.objects.get(id=self.doc_a.id)
        doc.tenant = self.tenant_b

        try:
            doc.save()
            self.fail("RLS should have blocked tenant_id change")
        except Exception:
            # Expected: RLS policy violation
            pass

    def test_superuser_bypasses_rls(self):
        """Test that superusers can see all data"""
        superuser = User.objects.create_superuser(
            username='admin',
            password='password',
            email='admin@example.com'
        )

        client = Client()
        client.login(username='admin', password='password')

        # Superuser should see all documents
        from your_app.models import Document
        documents = Document.objects.all()

        self.assertEqual(documents.count(), 2)  # Both tenants' documents


class RLSPerformanceTest(TestCase):
    """Test RLS performance overhead"""

    def test_rls_query_performance(self):
        """Verify RLS adds minimal query overhead"""
        import time
        from your_app.models import Document
        from django.db import connection

        # Create test data
        tenant = Tenant.objects.create(name="Test Tenant")
        for i in range(1000):
            Document.objects.create(
                tenant=tenant,
                title=f"Doc {i}",
                content=f"Content {i}"
            )

        # Set tenant context
        with connection.cursor() as cursor:
            cursor.execute("SET LOCAL app.current_tenant_id = %s", [tenant.id])

        # Measure query time
        start = time.time()
        documents = list(Document.objects.all())
        end = time.time()

        query_time = (end - start) * 1000  # ms

        # RLS should add <5ms overhead for 1000 rows
        self.assertLess(query_time, 50, f"Query took {query_time}ms (too slow)")
        self.assertEqual(len(documents), 1000)
'''


# ============================================================================
# 7. DEPLOYMENT CHECKLIST
# ============================================================================

DEPLOYMENT_CHECKLIST = '''
# PostgreSQL RLS Deployment Checklist

## Pre-Deployment

- [ ] PostgreSQL version >= 9.5
- [ ] Created app_user (no BYPASSRLS)
- [ ] Created migration_user (with BYPASSRLS)
- [ ] Granted appropriate permissions to both users
- [ ] Updated DATABASE settings with app_user
- [ ] Added TenantRLSMiddleware to MIDDLEWARE
- [ ] All models with tenant_id identified
- [ ] Migration created to enable RLS on all tables
- [ ] RLS policies created for all tenant-scoped tables

## Testing

- [ ] Unit tests pass for middleware
- [ ] Integration tests pass for cross-tenant isolation
- [ ] Verified user_a cannot access user_b's data
- [ ] Verified SQL injection cannot bypass RLS
- [ ] Verified INSERT/UPDATE policies work correctly
- [ ] Verified DELETE policy works correctly
- [ ] Verified WebSocket consumers set tenant context
- [ ] Performance tests show <5% overhead

## Deployment Steps

1. **Backup Database**
   ```bash
   pg_dump -U postgres your_database > backup_before_rls.sql
   ```

2. **Create Database Users**
   ```bash
   psql -U postgres -f create_users.sql
   ```

3. **Run Migrations (with migration_user)**
   ```bash
   export DJANGO_MIGRATE=1
   python manage.py migrate
   ```

4. **Verify RLS Enabled**
   ```sql
   SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public';
   ```

5. **Deploy Application (with app_user)**
   ```bash
   # Update DATABASE_URL to use app_user
   export DATABASE_URL=postgresql://app_user:password@localhost/db
   ```

6. **Test in Production**
   - Create test users in different tenants
   - Verify cross-tenant isolation
   - Monitor logs for RLS violations

## Post-Deployment

- [ ] Monitor application logs for RLS errors
- [ ] Set up alerts for "permission denied for table" errors
- [ ] Document RLS architecture for team
- [ ] Train developers on RLS behavior
- [ ] Add RLS checks to CI/CD pipeline

## Rollback Plan

If issues occur:

1. **Disable RLS (Emergency)**
   ```sql
   ALTER TABLE table_name DISABLE ROW LEVEL SECURITY;
   ```

2. **Restore from Backup**
   ```bash
   psql -U postgres your_database < backup_before_rls.sql
   ```

3. **Revert Migration**
   ```bash
   python manage.py migrate app_name previous_migration_name
   ```

## Monitoring

Monitor these metrics:

- RLS policy violations (permission denied errors)
- Query performance (should be <5% slower)
- Middleware execution time
- Tenant context setting failures

Set up alerts for:

- Spike in "permission denied" errors
- Queries without tenant context
- Users with NULL tenant_id accessing data
'''


# ============================================================================
# 8. DOCUMENTATION
# ============================================================================

DOCUMENTATION = '''
# PostgreSQL Row-Level Security (RLS) for Tenant Isolation

## Overview

Row-Level Security (RLS) is a PostgreSQL feature that enforces access control
at the database level. This provides defense-in-depth security for multi-tenant
applications by ensuring tenant isolation even if application code has bugs.

## How It Works

### 1. RLS Policies

RLS policies define which rows a database user can access:

```sql
CREATE POLICY tenant_isolation_policy ON documents
USING (tenant_id = current_setting('app.current_tenant_id')::int);
```

This policy says: "Users can only SELECT rows where tenant_id matches the
current_setting variable."

### 2. Tenant Context

The middleware sets the tenant context on each request:

```python
cursor.execute("SET LOCAL app.current_tenant_id = %s", [tenant_id])
```

This sets a PostgreSQL session variable that persists for the transaction.

### 3. Automatic Filtering

All queries are automatically filtered by RLS:

```python
# Application code
documents = Document.objects.all()

# Actual SQL executed by PostgreSQL
SELECT * FROM documents
WHERE tenant_id = current_setting('app.current_tenant_id')::int;
```

The WHERE clause is added by PostgreSQL, not Django!

## Security Benefits

### Defense-in-Depth

Even if application code has bugs, RLS prevents cross-tenant data leaks:

```python
# Buggy code (missing tenant filter)
def get_document(doc_id):
    return Document.objects.get(id=doc_id)

# With RLS: Returns 404 if doc belongs to different tenant
# Without RLS: Returns document from any tenant!
```

### SQL Injection Protection

RLS blocks SQL injection attacks:

```python
# Malicious SQL injection
query = f"SELECT * FROM documents WHERE id = {malicious_input}"

# RLS still enforces: WHERE tenant_id = current_tenant_id
# Attacker cannot access other tenant's data
```

### Direct Database Access

RLS protects against:
- Developers querying production database directly
- Admin tools with bugs
- Compromised database credentials

## Performance

RLS adds minimal overhead:
- Query time: +1-5% typically
- Memory: Negligible
- CPU: Negligible (index on tenant_id is key)

**Optimization tip:** Ensure tenant_id column is indexed!

```sql
CREATE INDEX idx_documents_tenant_id ON documents(tenant_id);
```

## Common Pitfalls

### 1. Forgetting to Set Tenant Context

```python
# BAD: No tenant context set
documents = Document.objects.all()  # Returns empty (RLS blocks everything)

# GOOD: Middleware sets context automatically
# (Just use authenticated requests)
```

### 2. Using Superuser in Application

```python
# BAD: Application connects as superuser
DATABASES = {
    'default': {
        'USER': 'postgres',  # Bypasses RLS!
    }
}

# GOOD: Use non-superuser with NOBYPASSRLS
DATABASES = {
    'default': {
        'USER': 'app_user',  # RLS enforced
    }
}
```

### 3. Not Handling Anonymous Users

```python
# BAD: No tenant_id for anonymous users
if not request.user.tenant_id:
    pass  # RLS will block all queries!

# GOOD: Set tenant_id to -1 (no matches)
tenant_id = request.user.tenant_id if request.user.tenant_id else -1
cursor.execute("SET LOCAL app.current_tenant_id = %s", [tenant_id])
```

## Troubleshooting

### "No rows returned" Issue

**Symptom:** Queries return empty results

**Cause:** Tenant context not set or set incorrectly

**Solution:**
1. Check middleware is in MIDDLEWARE list
2. Verify middleware runs after AuthenticationMiddleware
3. Check user has tenant_id attribute
4. Enable DEBUG logging for middleware

### "Permission Denied" Errors

**Symptom:** `permission denied for table documents`

**Cause:** Application user lacks table permissions

**Solution:**
```sql
GRANT SELECT, INSERT, UPDATE, DELETE ON documents TO app_user;
```

### Migrations Fail

**Symptom:** Migrations fail with RLS errors

**Cause:** Migration user doesn't have BYPASSRLS

**Solution:**
```sql
ALTER USER migration_user WITH BYPASSRLS;
```

## Testing Strategy

### Unit Tests

Test middleware in isolation:

```python
def test_middleware_sets_context(self):
    request = self.factory.get('/')
    request.user = self.user_a
    middleware = TenantRLSMiddleware(get_response)
    middleware.process_request(request)
    # Verify SET LOCAL was called
```

### Integration Tests

Test end-to-end isolation:

```python
def test_cross_tenant_isolation(self):
    client.login(username='user_a')
    response = client.get('/api/documents/')
    # Should only see tenant_a documents
```

### Security Tests

Test attack scenarios:

```python
def test_sql_injection_blocked(self):
    # Try to inject SQL to access other tenant
    # Verify RLS blocks it
```

## References

- PostgreSQL RLS Documentation: https://www.postgresql.org/docs/current/ddl-rowsecurity.html
- AWS Multi-Tenant Blog: https://aws.amazon.com/blogs/database/multi-tenant-data-isolation-with-postgresql-row-level-security/
- Citus Data Blog: https://www.citusdata.com/blog/2018/08/01/securing-multi-tenant-apps-with-postgres-row-level-security/
'''


# ============================================================================
# HELPER FUNCTIONS FOR CODE GENERATION
# ============================================================================

def generate_migration_for_models(model_names, table_names, tenant_column='tenant_id'):
    """
    Generate Django migration code to enable RLS on specific models.

    Args:
        model_names: List of model names (e.g., ['Document', 'Comment'])
        table_names: List of table names (e.g., ['app_document', 'app_comment'])
        tenant_column: Name of tenant column (default: 'tenant_id')

    Returns:
        Complete migration file content
    """
    enable_rls_sql = "\n".join([
        ENABLE_RLS_SQL_TEMPLATE.format(table_name=table)
        for table in table_names
    ])

    create_policies_sql = "\n".join([
        CREATE_POLICY_SQL_TEMPLATE.format(
            table_name=table,
            table_name_clean=table.replace('.', '_').replace('-', '_'),
            tenant_column=tenant_column
        )
        for table in table_names
    ])

    drop_policies_sql = "\n".join([
        DROP_POLICY_SQL_TEMPLATE.format(
            table_name=table,
            table_name_clean=table.replace('.', '_').replace('-', '_')
        )
        for table in table_names
    ])

    disable_rls_sql = "\n".join([
        DISABLE_RLS_SQL_TEMPLATE.format(table_name=table)
        for table in table_names
    ])

    table_list = ", ".join(table_names)
    table_list_comma = ", ".join(table_names)

    migration = MIGRATION_TEMPLATE.format(
        table_list=table_list,
        enable_rls_sql=enable_rls_sql,
        create_policies_sql=create_policies_sql,
        drop_policies_sql=drop_policies_sql,
        disable_rls_sql=disable_rls_sql,
        table_list_comma=table_list_comma
    )

    return migration


if __name__ == '__main__':
    # Example usage
    print("=" * 80)
    print("Shield AI - CSEC-33 Fix Template")
    print("PostgreSQL Row-Level Security (RLS) Implementation")
    print("=" * 80)
    print()
    print("Available Templates:")
    print("1. MIGRATION_TEMPLATE - Django migration for enabling RLS")
    print("2. MIDDLEWARE_TEMPLATE - Tenant context middleware")
    print("3. WEBSOCKET_CONSUMER_TEMPLATE - WebSocket RLS integration")
    print("4. DATABASE_USER_SETUP_SQL - PostgreSQL user setup")
    print("5. SETTINGS_TEMPLATE - Django settings configuration")
    print("6. INTEGRATION_TEST_TEMPLATE - RLS integration tests")
    print("7. DEPLOYMENT_CHECKLIST - Deployment steps")
    print("8. DOCUMENTATION - Complete RLS documentation")
    print()
    print("Example: Generate migration for Document and Comment models")
    print()

    migration = generate_migration_for_models(
        model_names=['Document', 'Comment'],
        table_names=['app_document', 'app_comment']
    )

    print(migration[:500] + "...\n")
    print("Full migration saved to: migrations/0001_enable_rls.py")
