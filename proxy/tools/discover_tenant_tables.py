"""Auto-discovery tool for tenant-scoped tables.

Scans a PostgreSQL ``information_schema`` to find tables that have a
``tenant_id`` or ``customer_id`` column, then generates idempotent RLS
migration SQL.

Usage (standalone)::

    python -m proxy.tools.discover_tenant_tables postgresql://...

Or programmatically::

    tables = await discover_tenant_tables(pool)
    sql = generate_rls_migration(tables)
"""

from __future__ import annotations

import re
import sys
from typing import Any

# Tenant column names we look for
_TENANT_COLUMNS = ("tenant_id", "customer_id")

# Safe PostgreSQL identifier: lowercase letters, digits, underscores; 1-63 chars.
_PG_IDENT_RE = re.compile(r"^[a-z_][a-z0-9_]{0,62}$")

# UUID-type names in PostgreSQL
_UUID_TYPES = frozenset({"uuid"})


async def discover_tenant_tables(pool: Any) -> list[dict[str, str]]:
    """Scan ``information_schema.columns`` for tables with tenant columns.

    Returns a list of dicts with keys ``table_name``, ``column_name``,
    and ``data_type``.
    """
    async with pool.acquire() as conn:
        rows = await conn.fetch(
            """
            SELECT table_name, column_name, data_type
            FROM information_schema.columns
            WHERE table_schema = 'public'
              AND column_name = ANY($1)
            ORDER BY table_name
            """,
            list(_TENANT_COLUMNS),
        )
        return [dict(r) for r in rows]


def generate_rls_migration(tables: list[dict[str, str]]) -> str:
    """Generate idempotent RLS SQL from discovered tables.

    Handles UUID vs VARCHAR column types automatically.
    """
    if not tables:
        return "-- No tenant-scoped tables found.\n"

    lines = [
        "-- Auto-generated RLS migration",
        "-- Generated by proxy.tools.discover_tenant_tables",
        "",
    ]

    for tbl in tables:
        table_name = tbl["table_name"]
        column_name = tbl["column_name"]
        data_type = tbl.get("data_type", "").lower()

        # Validate identifiers before interpolating into SQL
        if not _PG_IDENT_RE.match(table_name):
            lines.append(f"-- SKIPPED: unsafe table name {table_name!r}")
            continue
        if not _PG_IDENT_RE.match(column_name):
            lines.append(f"-- SKIPPED: unsafe column name {column_name!r}")
            continue

        cast = "::uuid" if data_type in _UUID_TYPES else ""

        lines.append(f"-- Table: {table_name} (column: {column_name}, type: {data_type})")
        lines.append(f"ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY;")
        lines.append(f"DROP POLICY IF EXISTS tenant_isolation ON {table_name};")
        lines.append(
            f"CREATE POLICY tenant_isolation ON {table_name}\n"
            f"    USING ({column_name} = current_setting('app.current_tenant_id', true){cast})\n"
            f"    WITH CHECK ({column_name} = current_setting('app.current_tenant_id', true){cast});"
        )
        lines.append("")

    return "\n".join(lines)


async def _main(dsn: str) -> None:
    """CLI entry point."""
    import asyncpg  # noqa: PLC0415

    pool = await asyncpg.create_pool(dsn, min_size=1, max_size=2)
    try:
        tables = await discover_tenant_tables(pool)
        if not tables:
            print("No tenant-scoped tables found.")
            return
        print(f"Found {len(tables)} tenant-scoped table(s):\n")
        for t in tables:
            print(f"  {t['table_name']}.{t['column_name']} ({t['data_type']})")
        print("\n-- Generated migration SQL --\n")
        print(generate_rls_migration(tables))
    finally:
        await pool.close()


if __name__ == "__main__":
    import asyncio

    if len(sys.argv) < 2:
        print(f"Usage: python -m {__name__} <postgresql://...>")
        sys.exit(1)
    asyncio.run(_main(sys.argv[1]))
